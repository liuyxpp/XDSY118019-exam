# 代码使用方法
- 直接运行即可

# 问题描述及实现思路
- 实现Bisection算法函数
1. 将区间[a,b]等分为两个⼦区间[a,c]和[c,b]，其中c=(a+b)/2.
2. 如果f(a)f(c)<0，则令b=c，否则令a=c.
3. 重复上述过程，直到区间⻓度b-a⼩于给定的阈值$\varepsilon$，即可得到根的近似值.

- 实现Newton算法函数
1. 已知函数$f(x)$在某个点$x_0$的函数值$f(x_0)$及其导数$f’(x_0)$，令${x_1=x_0-f(x_0)/f’(x_0)}$，则$x_1$为函数$f(x)$在$x_0$附近的⼀个根的近似值.
2. 利⽤$x_1$代替$x_0$重复上述过程，即可得到根的近似值$x_2$.
3. 重复上述过程，即可求得根的近似值$x_n$.
4. 如果前后两个近似根⼩于某个给定的阈值$\varepsilon$，则认为已经求得根的近似值.

- ⽤Numpy/Scipy中的求根函数对以下⽅程进⾏求解，并与上述两种算法的结果进⾏⽐较（⽬标误差设置为$\varepsilon=10^{-10}$ ）：
1. $2x=tan(x),x∈[-0.2,1.4].$
2. $e^{x+1}=2+x,x∈[-2,2].$
3. $x^{-2}=sin(x),x∈[0.5,4\Pi].$（提示： 在这个区间函数有多个根，请⽤合适的画图⽅法先⼤致确认每个根的区间或初始解再逐⼀求解）</br>
调用上述两个函数以及scipy.optimize.fsolve()即可

- 误差分析：分别将上述两种算法应⽤于求解${x^2-2=0}$在区间(1,2)内的根，⽐较两种算法的收敛速度，并将结果⽤图表形式展示出来.</br>
Newton算法收敛速度比Bisection算法快
![Alt text](image.png)


