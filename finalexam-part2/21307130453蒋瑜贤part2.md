# 21307130453 è’‹ç‘œè´¤ æœŸæœ« Part 2
- [[#1. `find.py`|1. `find.py`]]
	- [[#1. `find.py`#1. ä¸º`find_name_value`æ·»åŠ åŠŸèƒ½æè¿°|1. ä¸º`find_name_value`æ·»åŠ åŠŸèƒ½æè¿°]]
	- [[#1. `find.py`#2. è®¾è®¡æµ‹è¯•æ ·ä¾‹|2. è®¾è®¡æµ‹è¯•æ ·ä¾‹]]
		- [[#2. è®¾è®¡æµ‹è¯•æ ·ä¾‹#ä¿®æ”¹ä»£ç |ä¿®æ”¹ä»£ç ]]
			- [[#ä¿®æ”¹ä»£ç #è¿”å›ç¬¬ä¸€ä¸ªpair|è¿”å›ç¬¬ä¸€ä¸ªpair]]
			- [[#ä¿®æ”¹ä»£ç #è¿”å›æ‰€æœ‰pair|è¿”å›æ‰€æœ‰pair]]
	- [[#1. `find.py`#ç»“æœ|ç»“æœ]]
- [[#2. Matlab ä½œå›¾|2. Matlab ä½œå›¾]]
- [[#3. `Mathematica` æ±‚è§£|3. `Mathematica` æ±‚è§£]]
	- [[#3. `Mathematica` æ±‚è§£#1.|1.]]
	- [[#3. `Mathematica` æ±‚è§£#2.|2.]]
- [[#4. Markdownå†™ä½œ|4. Markdownå†™ä½œ]]

## 1. `find.py`

### 1. ä¸º`find_name_value`æ·»åŠ åŠŸèƒ½æè¿°

å‡½æ•° `find_name_value` ç”¨äºå°†æ•°æ®ç›®å½•çš„åç§°æ‹†åˆ†ä¸ºä¸€ä¸ª (name, value) å…ƒç»„ã€‚ç›®å½•åç§°çš„æ ¼å¼ä¸º `<name><value>`ï¼Œå…¶ä¸­ `<value>` å¯ä»¥æ˜¯æ­£æ•°æˆ–è´Ÿæ•°ã€‚å¦‚æœå€¼æ˜¯è´Ÿæ•°ï¼Œåˆ™åº”åœ¨å…¶åè·Ÿä¸€ä¸ª 'n'ã€‚ä¾‹å¦‚ï¼Œ'phi0.1' åº”è¿”å› ('phi', 0.1)ï¼Œ'xN14.2' åº”è¿”å› ('xN', 14.2)ï¼Œ'kappa0.5n' åº”è¿”å› ('kappa', -0.5)ã€‚

### 2. è®¾è®¡æµ‹è¯•æ ·ä¾‹

- æ­£å¸¸è¾“å…¥ï¼šæ­¤æ—¶è¾“å…¥çš„å­—ç¬¦ä¸²ç¬¦åˆä¸Šè¿°æ ¼å¼ï¼Œå¦‚ 'phi0.1'ï¼Œ'xN14.2'ï¼Œ'kappa0.5n'ã€‚

| è¾“å…¥                          | é¢„æœŸè¾“å‡º            | å®é™…è¾“å‡º            | æµ‹è¯•æ˜¯å¦é€šè¿‡ |
| --------------------------- | --------------- | --------------- | ------ |
| 'phi0.1'                    | ('phi', 0.1)    | ('phi', 0.1)    | æ˜¯      |
| 'xN14.2'                    | ('xN', 14.2)    | ('xN', 14.2)    | æ˜¯      |
| 'kappa0.5n'                 | ('kappa', -0.5) | ('kappa', -0.5) | æ˜¯      |
| 'beta0.2n'                  | ('beta', -0.2)  | ('beta', -0.2)  | æ˜¯      |
| '"phi0.1n_xN14.2_kappa0.5n" | ('phi', -0.1)   | ('phi', 0.1)    | **å¦**  |

> é”™è¯¯ä¸€ï¼šç”±äºå‡½æ•°åªåˆ¤æ–­ç¬¬ä¸‰ä¸ªåŒ¹é…åˆ°çš„å­—ç¬¦æ˜¯å¦ä¸º`n`ï¼Œè‹¥nåé¢è¿˜æœ‰å­—ç¬¦ï¼Œè¿™ä¸ª`n`å°±æ— æ³•åˆ¤æ–­æˆåŠŸã€‚

- å¼‚å¸¸è¾“å…¥ï¼šæ­¤æ—¶è¾“å…¥çš„å­—ç¬¦ä¸²ä¸ç¬¦åˆä¸Šè¿°æ ¼å¼ï¼Œå¦‚ 'gemma'ï¼Œ'phi0.1x'
  
| è¾“å…¥                  | é¢„æœŸè¾“å‡º               | å®é™…è¾“å‡º            | æµ‹è¯•æ˜¯å¦é€šè¿‡ |
| ------------------- | ------------------ | --------------- | ------ |
| 'gemma'             | ('gemma', None)    | ('gemma', None) | æ˜¯      |
| 'alpha-0.3n'        | ('alpha-', '-0.3') | ValueError      | **å¦**  |
| 'alpha-0.3_phi0.1x' | ('alpha-', '0.3')  | ('alpha', -0.3) | **å¦**  |
| 'phi0.1x'           | ('phi', 0.1)       | ('phi', 0.1)    | æ˜¯      |

> é”™è¯¯äºŒï¼šç”±äºå‡½æ•°æ²¡æœ‰å¤„ç†è´Ÿå·çš„æƒ…å†µï¼Œæ‰€ä»¥å½“è¾“å…¥å­—ç¬¦ä¸²ä¸­çš„æ•°å­—ä¸ºè´Ÿæ•°æ—¶ï¼Œåº”è¯¥æŠŠè´Ÿæ•°ä½œä¸ºåç§°çš„ä¸€éƒ¨åˆ†ï¼Œè€Œä¸æ˜¯ä½œä¸ºæ•°å€¼ã€‚

> é”™è¯¯ä¸‰ï¼šç”±äºå‡½æ•°æ²¡æœ‰å¤„ç†å­—ç¬¦ä¸²ä¸­åŒ…å«å¤šä¸ªpairçš„æƒ…å†µï¼Œè¿™é‡Œé¢˜ç›®ä¸­æ²¡æœ‰è¯´æ˜å¦‚ä½•å¤„ç†ï¼Œå¯ä»¥è¿”å›æ‰€æœ‰çš„pairï¼Œä¹Ÿå¯ä»¥è¿”å›ç¬¬ä¸€ä¸ªpairã€‚

- è¾¹ç•Œè¾“å…¥ï¼š

|è¾“å…¥|é¢„æœŸè¾“å‡º|å®é™…è¾“å‡º| æµ‹è¯•æ˜¯å¦é€šè¿‡|
| --- | --- | --- | --- |
| '' | ('', None) | ('', None) | æ˜¯ |
| '23' |('', 23.0) | ('', 23.0) |  æ˜¯ |
| 'phi' | ('phi', None) | ('phi', None) | æ˜¯ |
| 'phi0.0n' | ('phi', -0.0) | ('phi', -0.0) | æ˜¯ |

#### ä¿®æ”¹ä»£ç 

ç”±äºé¢˜ç›®ä¸­æ²¡æœ‰å†™æ˜å¦‚ä½•å¤„ç†å¤šä¸ªpairçš„æƒ…å†µï¼Œè¿™é‡Œæä¾›ä¸¤ä¸ªç‰ˆæœ¬ï¼Œä¸€ä¸ªè¿”å›ç¬¬ä¸€ä¸ªpairï¼Œä¸€ä¸ªè¿”å›æ‰€æœ‰çš„pairã€‚

##### è¿”å›ç¬¬ä¸€ä¸ªpair

```python

def find_name_value(folder_name):
	'''Split the name of a data directory into a (name, value) tuple.

	The format of ``folder_name``:

		<name><value>

	If the value is negative, it should be followed by a 'n'.

	Examples:
		::

			phi0.1          # should return 'phi', 0.1
			xN14.2          # should return 'xN', 14.2
			kappa0.5n       # should return 'kappa', -0.5

	Args:
		folder_name (str): the name of a :term:`data directory`.

	Returns:
		tuple: a tuple contains:

			* name (str): variable name.
			* value (float): value of the variable.
	'''
	pattern = '([-+]?\d*\.\d+|[-+]?\d+)'
	rst = re.split(pattern, folder_name)
	if len(rst) < 2:
		return folder_name, None
	name = rst[0]
	valuestr = rst[1]
	# handle negative value
	if valuestr[0] == '-':
		value = valuestr[1:]
		name = name + '-'
	if len(rst) == 3
	sign_str = ''
	if len(rst) > 2:
		sign_str = rst[2]
	if sign_str[0] == 'n':
		value = '-' + valuestr
	else:
		value = valuestr

	return name, float(value)
```

##### è¿”å›æ‰€æœ‰pair

```python
import re

def find_name_value(folder_name):
    '''Split the name of a data directory into a list of (name, value) tuples.

    The format of ``folder_name``:

        <name><value>

    If the value is negative, it should be followed by a 'n'.

    Examples:
        ::

            phi0.1xN14.2kappa0.5n  # should return [('phi', 0.1), ('xN', 14.2), ('kappa', -0.5)]

    Args:
        folder_name (str): the name of a :term:`data directory`.

    Returns:
        list: a list of tuples, each containing:

            * name (str): variable name.
            * value (float): value of the variable.
    '''
    pattern = r'([a-zA-Z]+)(-?\d*\.\d+|-?\d+)(n?)'
    matches = re.findall(pattern, folder_name)
    result = []
    for match in matches:
        name, value_str, sign = match
        # handle negative value
        if value_str[0] == '-':
            value_str = value_str[1:]
            name = name + '-'
        value = float(value_str)
        if sign == 'n':
            value = -value
        result.append((name, value))
    return result

```
### ç»“æœ

è‹¥ä½¿ç”¨è¿”å›ç¬¬ä¸€ä¸ªpairçš„ç‰ˆæœ¬ï¼Œç»“æœä¸º

```
('phi', 0.1)
('a', 1.0)
```

è‹¥ä½¿ç”¨è¿”å›æ‰€æœ‰pairçš„ç‰ˆæœ¬ï¼Œç»“æœä¸º

```
[('phi', 0.1), ('xN', 14.2), ('kappa', -0.5)]
[('a', 1.0), ('b', -14.0), ('n', 0.0), ('c', 0.2)]

```
## 2. Matlab ä½œå›¾

Matlab ä»£ç 
```matlab
% å‚æ•°
R = 3;
r = 1;

% åˆ›å»ºè§’åº¦ç½‘æ ¼
theta = linspace(0, 2*pi, 100);
phi = linspace(0, 2*pi, 100);
[Theta, Phi] = meshgrid(theta, phi);

% è®¡ç®—åœ†ç¯çš„åæ ‡
X = (R + r * cos(Theta)) .* cos(Phi);
Y = (R + r * cos(Theta)) .* sin(Phi);
Z = r * sin(Theta);

% ç»˜åˆ¶åœ†ç¯
surf(X, Y, Z)

% è®¾ç½®å›¾åƒå±æ€§
axis equal
xlabel('X')
ylabel('Y')
zlabel('Z')
title('Torus (ç¯é¢)')
shading interp
```
è¿è¡Œç»“æœï¼š
![alt text](image-1.png)

## 3. `Mathematica` æ±‚è§£

### 1. 

ä»£ç ä¸ºï¼š
```mathematica
Sum[1/(n^3 + n^2), {n, 1, Infinity}]
```
![alt text](image-2.png)

### 2. 

ä»£ç ä¸ºï¼š
```mathematica
Integrate[Sqrt[x] Log[x]/(x + 1)^2, {x, 0, Infinity}]
```
![alt text](image-3.png)
## 4. Markdownå†™ä½œ
**Q**: Find the solution of the following equation with respect to $\theta$:
$$A\cos\theta + B\sin \theta + C = 0$$
**A**: 
let $x_1 = \cos\theta$ and $x_2 = \sin \theta$, then the solution is given by the intersection of the circle and the line:
$$x_1^2 + x_2^2 = 1$$
$$Ax_1 + Bx_2 + C = 0$$
We reformulate the equations in a parametric form:
$$|x|^2 = 1$$
$$x(t)=a+tb$$
where $\mathbf{x} = (x_1, x_2)$, $\mathbf a = (0, âˆ’ğ¶/ğµ)$, $\mathbf b = (âˆ’ğ¶/ğ´, ğ¶/ğµ)$, and $t$ is a parameter. The intersection points satisfy
the following equation:
$$|\mathbf a+t\mathbf b|^2 = 1$$
which can be solved for ğ‘¡ to find the intersection points:
$$t_{1,2} = \frac{-\mathbf{a} \cdot \mathbf{b} \pm \sqrt{(\mathbf{a} \cdot \mathbf{b})^2 - |\mathbf{b}|^2 (|\mathbf{a}|^2 - 1)}}{|\mathbf{b}|^2}$$
